["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.core.matrix.linear","~:imports",null,"~:requires",["^ ","~$mp","~$clojure.core.matrix.protocols","^<","^<"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$svd",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","~:line",90,"~:column",7,"~:end-line",90,"~:end-column",10,"~:arglists",["~#list",["~$quote",["^I",[["~$m","~$options"],["~$m"]]]]],"~:doc","Computes the Singular Value decomposition of a matrix.\n   Returns a map containing the keys [:U :S :V*] such that:\n     M = U.S.V*\n\n   Where\n     - U is an unitary matrix\n     - S is a sequence whose elements are the singular values of the original matrix\n     - V* is an unitary matrix\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [U S V*]} (svd M)] ....)\n                   (let [{:keys [S]} (svd M {:return [:S]})] ....)","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"~:arglists-meta",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/svd","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",10,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m","^K"],["~$m"]]],"~:protocol-impl",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"~:methods",[["^ ","^O",2,"^N",false,"~:tag","~$any"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",90,"^F",90,"^P",2,"~:fn-var",true,"^H",["^I",[["~$m","^K"],["~$m"]]],"^L","Computes the Singular Value decomposition of a matrix.\n   Returns a map containing the keys [:U :S :V*] such that:\n     M = U.S.V*\n\n   Where\n     - U is an unitary matrix\n     - S is a sequence whose elements are the singular values of the original matrix\n     - V* is an unitary matrix\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [U S V*]} (svd M)] ....)\n                   (let [{:keys [S]} (svd M {:return [:S]})] ....)"],"~$lu",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",72,"^E",7,"^F",72,"^G",9,"^H",["^I",["^J",["^I",[["~$m","^K"],["~$m"]]]]],"^L","Computes the LU(P) decomposition of a matrix with partial row pivoting.\n   Returns a map containing the keys [:L :U :P], such that:\n     P.A = L.U\n\n   Where\n     - L is a lower triangular matrix\n     - U is an upper triangular matrix\n     - P is a permutation matrix\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [L U P]} (lu A)] ....)\n                   (let [{:keys [L U]} (lu M {:return [:L :U]})] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/lu","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",9,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m","^K"],["~$m"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",2,"^N",false,"^V","^W"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",72,"^F",72,"^P",2,"^X",true,"^H",["^I",[["~$m","^K"],["~$m"]]],"^L","Computes the LU(P) decomposition of a matrix with partial row pivoting.\n   Returns a map containing the keys [:L :U :P], such that:\n     P.A = L.U\n\n   Where\n     - L is a lower triangular matrix\n     - U is an upper triangular matrix\n     - P is a permutation matrix\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [L U P]} (lu A)] ....)\n                   (let [{:keys [L U]} (lu M {:return [:L :U]})] ....)"],"~$cholesky",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",53,"^E",7,"^F",53,"^G",15,"^H",["^I",["^J",["^I",[["~$m","^K"],["~$m"]]]]],"^L","Computes the Cholesky decomposition of a hermitian, positive definite matrix.\n   Returns a map containing two matrices with the keys [:L :L*] such that\n\n   Such that:\n     M = L.L*\n\n   Where\n     - M must be a hermitian, positive definite matrix\n     - L is a lower triangular matrix\n     - L* is the conjugate transpose of L\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [L L*]} (cholesky M)] ....)\n                   (let [{:keys [L*]} (cholesky M {:return [:L*]})] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/cholesky","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",15,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m","^K"],["~$m"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",2,"^N",false,"^V","^W"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",53,"^F",53,"^P",2,"^X",true,"^H",["^I",[["~$m","^K"],["~$m"]]],"^L","Computes the Cholesky decomposition of a hermitian, positive definite matrix.\n   Returns a map containing two matrices with the keys [:L :L*] such that\n\n   Such that:\n     M = L.L*\n\n   Where\n     - M must be a hermitian, positive definite matrix\n     - L is a lower triangular matrix\n     - L* is the conjugate transpose of L\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [L L*]} (cholesky M)] ....)\n                   (let [{:keys [L*]} (cholesky M {:return [:L*]})] ....)"],"~$least-squares",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",141,"^E",7,"^F",141,"^G",20,"^H",["^I",["^J",["^I",[["~$a","~$b"]]]]],"^L","Computes least-squares solution to a linear matrix equation.\n\n   Intended usage: (let [X (least-squares A B)] ....)"],"^7","~$clojure.core.matrix.linear/least-squares","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",20,"^Q",["^I",[["~$a","~$b"]]],"^T",null,"^R",["^I",[null,null]],"^E",1,"^N",false,"^D",141,"~:ret-tag","^W","^F",141,"^P",2,"^X",true,"^H",["^I",["^J",["^I",[["~$a","~$b"]]]]],"^L","Computes least-squares solution to a linear matrix equation.\n\n   Intended usage: (let [X (least-squares A B)] ....)"],"~$qr",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",29,"^E",7,"^F",29,"^G",9,"^H",["^I",["^J",["^I",[["~$m",["^ ","~:keys",["~$return","~$compact"],"~:or",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]]]],"^L","Computes QR decomposition of a full rank matrix.\n   Returns a map containing matrices of an input matrix type with the keys [:Q :R] such that:\n        M = Q.R\n\n   Where:\n    - Q is an orthogonal matrix\n    - R is an upper triangular matrix (= right triangular matrix)\n   If :return parameter is specified in options map, it returns only specified keys.\n   If :compact parameter is specified in options map, compact versions of matrices are returned.\n\n   Returns nil if decomposition is impossible.\n\n   Intended usage: (let [{:keys [Q R]} (qr M)] ....)\n                   (let [{:keys [R]} (qr M {:return [:R]})] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^H",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/qr","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",9,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^H",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",2,"^N",false,"^V","^W"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",29,"^F",29,"^P",2,"^X",true,"^H",["^I",[["~$m",["^ ","^15",["^16","^17"],"^18",["^ ","^16",["~:Q","~:R"],"^17",false]]],["~$m"]]],"^L","Computes QR decomposition of a full rank matrix.\n   Returns a map containing matrices of an input matrix type with the keys [:Q :R] such that:\n        M = Q.R\n\n   Where:\n    - Q is an orthogonal matrix\n    - R is an upper triangular matrix (= right triangular matrix)\n   If :return parameter is specified in options map, it returns only specified keys.\n   If :compact parameter is specified in options map, compact versions of matrices are returned.\n\n   Returns nil if decomposition is impossible.\n\n   Intended usage: (let [{:keys [Q R]} (qr M)] ....)\n                   (let [{:keys [R]} (qr M {:return [:R]})] ....)"],"~$norm",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",9,"^E",7,"^F",9,"^G",11,"^H",["^I",["^J",["^I",[["~$m"],["~$m","~$p"]]]]],"^L","Computes the norm of a matrix or vector.\n\n   By default calculates 2-norm for vectors and Frobenius 2-norm for matrices. The optional p argument specifies use of the p-norm instead.\n\n   Special cases of p argument:\n   Double/POSITIVE_INFINITY - Infinity norm\n\n   Intended usage: (let [n (norm v 1)] ....)\n                   (let [n (norm v Double/POSITIVE_INFINITY)] ....)\n                   (let [n (norm v)] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m"],["~$m","~$p"]]],"^H",["^I",[["~$m"],["~$m","~$p"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/norm","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",11,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m"],["~$m","~$p"]]],"^H",["^I",[["~$m"],["~$m","~$p"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m"],["~$m","~$p"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",1,"^N",false,"^V","^W"],["^ ","^O",2,"^N",false,"^V","^W"]],"^D",9,"^F",9,"^P",2,"^X",true,"^H",["^I",[["~$m"],["~$m","~$p"]]],"^L","Computes the norm of a matrix or vector.\n\n   By default calculates 2-norm for vectors and Frobenius 2-norm for matrices. The optional p argument specifies use of the p-norm instead.\n\n   Special cases of p argument:\n   Double/POSITIVE_INFINITY - Infinity norm\n\n   Intended usage: (let [n (norm v 1)] ....)\n                   (let [n (norm v Double/POSITIVE_INFINITY)] ....)\n                   (let [n (norm v)] ....)"],"~$eigen",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",108,"^E",7,"^F",108,"^G",12,"^H",["^I",["^J",["^I",[["~$m","^K"],["~$m"]]]]],"^L","Computes the Eigen decomposition of a diagonalisable matrix.\n   Returns a map containing matrices for each of the the keys [:Q :A] such that:\n\n      M l= Q.A.Q<sup>-1</sup>\n\n   Where:\n     - Q is a matrix where each column is the ith normalised eigenvector of M\n     - A is a diagonal matrix whose diagonal elements are the eigenvalues.\n     - Q<sup>-1</sup> is the inverse of Q\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [Q A]} (eigen M)] ....)\n                   (let [{:keys [A]} (eigen M {:return [:A]})] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/eigen","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",12,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$m","^K"],["~$m"]]],"^H",["^I",[["~$m","^K"],["~$m"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$m","^K"],["~$m"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",2,"^N",false,"^V","^W"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",108,"^F",108,"^P",2,"^X",true,"^H",["^I",[["~$m","^K"],["~$m"]]],"^L","Computes the Eigen decomposition of a diagonalisable matrix.\n   Returns a map containing matrices for each of the the keys [:Q :A] such that:\n\n      M l= Q.A.Q<sup>-1</sup>\n\n   Where:\n     - Q is a matrix where each column is the ith normalised eigenvector of M\n     - A is a diagonal matrix whose diagonal elements are the eigenvalues.\n     - Q<sup>-1</sup> is the inverse of Q\n\n   If :return parameter is specified in options map, it returns only specified keys.\n\n   Intended usage: (let [{:keys [Q A]} (eigen M)] ....)\n                   (let [{:keys [A]} (eigen M {:return [:A]})] ....)"],"~$rank",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",23,"^E",7,"^F",23,"^G",11,"^H",["^I",["^J",["^I",[["~$m"]]]]],"^L","Computes the rank of a matrix, i.e. the number of linearly independent rows.\n\n   Intended usage: (let [r (rank m)] ....)"],"^7","~$clojure.core.matrix.linear/rank","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",11,"^Q",["^I",[["~$m"]]],"^T",null,"^R",["^I",[null,null]],"^E",1,"^N",false,"^D",23,"^13","^W","^F",23,"^P",1,"^X",true,"^H",["^I",["^J",["^I",[["~$m"]]]]],"^L","Computes the rank of a matrix, i.e. the number of linearly independent rows.\n\n   Intended usage: (let [r (rank m)] ....)"],"~$solve",["^ ","^A",null,"^B",["^ ","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^D",126,"^E",7,"^F",126,"^G",12,"^H",["^I",["^J",["^I",[["~$a","~$b"],["~$a"]]]]],"^L","Solves a linear matrix equation, or system of linear scalar equations, i.e. finds the\n   value X such that:\n\n     A.X = B\n\n   Where:\n     - A is a square matrix containing the coefficients of the linear system\n     - B is a vector containing the right-hand side of the linear system.\n   If B is missing, it is taken as an identity matrix and returns inverse of A\n\n   Intended usage: (let [X (solve A B)] ....)","^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$a","~$b"],["~$a"]]],"^H",["^I",[["~$a","~$b"],["~$a"]]],"^R",["^I",[null,null]]]],"^7","~$clojure.core.matrix.linear/solve","^C","/home/mkloim/.cljs/.aot_cache/1.10.520/9D6D7E2/clojure/core/matrix/linear.cljc","^G",12,"^M",["^ ","^N",false,"^O",2,"^P",2,"^Q",["^I",[["~$a","~$b"],["~$a"]]],"^H",["^I",[["~$a","~$b"],["~$a"]]],"^R",["^I",[null,null]]],"^Q",["^I",[["~$a","~$b"],["~$a"]]],"^T",null,"^O",2,"^R",["^I",[null,null]],"^E",1,"^N",false,"^U",[["^ ","^O",2,"^N",false,"^V","^W"],["^ ","^O",1,"^N",false,"^V","^W"]],"^D",126,"^F",126,"^P",2,"^X",true,"^H",["^I",[["~$a","~$b"],["~$a"]]],"^L","Solves a linear matrix equation, or system of linear scalar equations, i.e. finds the\n   value X such that:\n\n     A.X = B\n\n   Where:\n     - A is a square matrix containing the coefficients of the linear system\n     - B is a vector containing the right-hand side of the linear system.\n   If B is missing, it is taken as an identity matrix and returns inverse of A\n\n   Intended usage: (let [X (solve A B)] ....)"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:L","~:R","~:A","~:return","~:Q","~:V*","~:compact","~:P","~:U","~:S","~:L*"]],"~:order",["^1F","~:Q","~:R","^1H","~:L","^1I","~:U","~:P","~:S","^1G","~:A"]],"^L","Namespace for core.matrix linear algebra API.\n\n   These function complement the main core.matrix API with specialised functions for linear\n   algebra operations."]